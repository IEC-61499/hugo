---
title: 第三章 定义功能块类型
description: 定义功能块类型
toc: true
authors:
tags:
categories:
series:
date: '2021-01-02'
lastmod: '2021-01-02'
draft: false
weight: 30
---

在这一章，我们将综述如何为功能块建立类型定义。以及如何用类型定义来建立功能块实例。

特别地我们将：

* 描述不同形式功能块定义

* 描述如何定义事件和数据接口，和如何描述功能块的可见行为（visible behavior）

* 检查如何构建算法，并且连接到事件执行

* 考虑如何新建功能块实例

* 如何将功能块实例传递到复合功能块。

## 3.1类型和实例

在详细地描述IEC61499 定义功能块类型的机制之前，让我们先来回顾功能块类型和实例的作用。功能块类型定义描述了一个特定功能块的外部接口和内部行为。然而，功能块实例是示意功能块类型建立的功能块的工作拷贝。

在一个大型系统中，功能块类型定义包含在各种各样的库中。这些库具有各种目的。比如“控制算法”，“告警管理：，”输入传感器“等等。配置一个大型的基于功能块的系统需要选择适当的功能块类型库。清晰，准确，非二义性地定义功能块类型是有效地使用IEC61499 有着密切的关系。

## 3.2 功能块的不同形式

标准提供了两种功能块的类型定义，这就是基本功能块和复合功能块。每一个功能块都有其特定的特性和用途。如表3.1 所示，这两种功能块的主要特性在图3，1描述。值得注意的是，功能块和复合功能块都是驻留在一个单一的资源上。在它们的输入输出中，提供了变量的缺省数据值。基本功能块也需要内部存储器执行控制状态机，相比之下，复合功能块需要存储内部功能块和连接。
 
 
## 3.3 外部接口说明

所有的功能块都具有公共的外部接口，它定义了在应用和符合功能块中如何和它交互。IEC61499 区分静态接口结构（也就是事件和数据端口）和动态接口行为的定义（如何使用该接口）。

### 3.3.1 静态接口说明

如图3.2 显示的静态接口具有如下特点：

* 功能块的类型放置在主模块的中心，如图3.2 中的FB_Type_Name. 功能块的输入在功能块的左边，输出在功能块的右边。

* 输入事件从功能块上面部分的左边进入，右边输出。

* 输入输出变量的名称在功能块的内部，靠近引线的位置。

* 数据类型的输入输出分别在功能块底部的左边和右边。

![图 3.2](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-2.png)

图形化表示提供了足够的信息用于形式化类型说明。事实上，IEC61499 的一个主要目的就是图形化表示具有文本表示一样的精确性（文本语法或者XML）图形建模工具能够将图形形式转换成文本形式，反之亦然。

例如图 3.2 中的输入事件EI1进入功能块头部。必要时，它可以关联一个或者多个输入变量。输入事件于输入数据关联使用IEC61499 的修饰符WITH，在图形表示中，使用一个小方块连接事件和相关链的数据。

通常需要采样输入值优先于功能块的执行。在这个功能块的例子中，每当产生EI1事件时，都需要采用输入DI1和DI2，同样地，当事件EI2 产生时，要采样DI2，DI3和DI4输入值。

同样可以将输出事件和某些输出变量相关链。这用来标注这些输出变量以将被内部栓发更新，当输出事件点燃时，这些变量就绪。在图3.2功能块例子中，当功能块已经更新了DO1，DO2和DO3 后，产生输出事件EO2 。同样WITH 文本修饰符，而在图形化表示中使用小方块关联输出事件和输出数据。

注意：功能块每个输入和输出至少可以关联一个输入或者输出事件。
 
输入事件，比如在图3.2 中，EI1 事件从功能块头部进入。如果需要可以关联一个或者多个输入变量。输入事件与输入数据的关联使用IEC61499 的WITH修饰符 。在图形表示中，使用小方块连接事件与之关联的数据。

典型地，如果功能块需要在执行功能块之前采样输入数据，就需要这样做。在这个功能快的例子中，每当EI1 事件产生，需要采样DI1和DI2 输入。同样地，每当EI2 产生，需要采样DI2，DI3和DI4  的输入值。

同样需要某些输出事件与输出变量关联。这用来标志这些输出变量由内部算法更新，并且当输出事件点燃时立即有效。在图3.2功能块的例子中，当功能块更新输出DO1，DO2和DO3 之后，产生输出事件EO2 。使用同样WITH 文字修饰符和图形表示来关联输出事件和输出数据。

注意。功能块的每个输入输出都可以关联之少一个输入或者输出事件。这是由于当采样了输入值或者一个输出值被改变时，至少要产生一个事件信号。我们可以从另一个角度来看待这个问题，可以将事件以及它关联的数据当作一种消息，允许事件和它的数据在功能块之间传递。如果输入输出数据没有与任何事件关联（比如图3.2中的DI5）, 它就不能用于连接。它只能看作一个常量，给定固定的值，在应用执行中不能改变。

这一特点也意味着功能块必须具有存储器保持事件之间的采样值，以及输出事件点燃之间的输出值。当然，总是有可能收到事件及关联数据的速度比功能块存储和处理的速度快，标准指出，在这种情况下，调度功能将采取优先执行功能块的方式，避免这种过载现象发生。

事件可以定义成具有一个可选的事件类型。这可以使功能块设计成只接受某种类型的事件输入。提供事件类型能够提高设计的鲁棒性。这是数据类型的逻辑扩展。数据类型保证了设计的完整性，只允许兼容的数据的输入输出连接。同样地，数据类型保证了只有特定类型的事件被接受，保证了兼容性。

如果功能块的事件输入和输出没有给定的类型，施加缺省类型EVENT。这种通用类型EVENT 能够连接到其它任何类型为EVENT 的事件输入。相反，任何类型为EVENT 的事件输入能够接收任何类型的事件。

### 3.2.3 动态接口行为的定义
在上一节描述了静态接口，功能块基本上被全面地定义，可以在任何应用和复合功能块中使用，但是缺失的一个重要的点是描述如何使用这接口（以何种顺序发送输入事件，该事件发送时预计会有何种输入数据，以及事件将提供什么样的输出），为了描述动态行为，IEC499 定义为每个功能块使用服务序列图（service sequence diagrams）服务序列图是来自ISO 技术报告8509的时间序列图。他们用来表示功能块之间各种交互的时序关系。事实上，时序图经常用于通信标准中。展示各种消息和事件的顺序。软件建模顺序顺序图用来建立对象顺序交互的模型（比如UML）。

![图 3.3](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-3.png)

对于一个功能块定义，可以使用零个或多个服务顺序图来描述功能块的不同使用和执行编排。在IEC61499 中，服务时序图只是一项描述性任务，所以他们可用被省略。图3.3 是构建的一个IEC61499 服务时序图。有个时序图都有一个名称作为标识，显示在时序图的顶部中间位置。它有两个接口组成，用两根竖线分割开。通常左边接口标注FB接口，右边接口标注FB的内部。服务序列由一个或者多个服务交互构成，他们从上到下排列。服务交互由一个或多个服务图元(service primitives)组成. 服务图元可以是输入图元（进入接口的事件），也可以是输出图元（接口出来的事件）。
 
### 3.3.3 实例：3 比2 表决器

在这里使用一个简单的例子来展示功能块外部接口的说明。考虑一个功能块在三个输入A，B，C 上应用3比2表决算法。这个功能块的静态接口的模型在图3.5中描述。功能块有两个事件输入Vote和Reset。

![图 3.5](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-5.png)

Vote 事件用于触发表决处理，检查三个布尔输入端A，B和C 的状态。如果超过两个为TRUE，那么输出状态设置为TRUE，并且保留TRUE 状态，直到Reset 触发。当表决完成后，在Voted 事件输出端产生一个事件。Reset 事件触发State 输出的一个Reset，然后在Ready 输出端产生一个事件。

![图 3.6](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-6.png)

图3.6 显示的服务序列图以更规范的方式描述了这一行为。该服务序列图描述了4 个场景。然而这并不能涵盖所有的场景。如果要列出更多的可能的场景，不过一部分场景已经足以描述潜在使用者的行为。

Vote 功能块的文字语法描述如下：
```
FUNCTION_BLOCK VOTER (* Voter FB *)
(* Event definitions *)
EVENT_INPUT
Vote WITH A,B,C; (* Trigger Voter *)
Reset; (* Reset event *)
END_EVENT
EVENT_OUTPUT
Voted WITH State;
Ready WITH State;
END_EVENT
(* Variable definitions *)
VAR_INPUT
A : BOOL;
B : BOOL;
C : BOOL;
END_VAR
Figure 3.6 Service sequence diagrams describing the Voter function block’s
behaviour
Defining function block types 51
VAR_OUTPUT
State : BOOL;
END_VAR
(* Service sequence definitions *)
SERVICE Voter/FB_Internals
SEQUENCE NegativeVote
Voter.Vote(A:=FALSE, B:=FALSE, C:=TRUE) ->
Voter.Vote(State:=FALSE);
END_SEQUENCE
SEQUENCE PositiveVote
Voter.Vote(A:=TRUE, B:=FALSE, C:=TRUE) ->
Voter.Vote(State:=TRUE);
END_SEQUENCE
SEQUENCE UnvotedReset
Voter.Reset();
END_SEQUENCE
SEQUENCE VotedReset
Voter.Vote(A:=False, B:=TRUE, C:=TRUE) ->
Voter.Vote(State:=TRUE);
Voter.Reset() -> Voter.Reseted(State:=FALSE);
END_SEQUENCE
END_SERVICE
END_FUNCTION_BLOCK
``` 
 
从这个例子中我们可以看出如下几点：

* 包含在EVENT_和VAR_小节的文字定义描述功能块输入输出事件和数据。

* 数据与事件的关联在事件说明中完成，使用WITH 语句后跟数据点名称。

* 关键字SERVICE 和END_SERVICE 包含了服务序列的定义。从左到右地定义接口名称。左右接口名称使用“/”符号区分。

* 每个服务序列都由关键字SEQUENCE 导入，END_SEQUENCE 结束。序列定义定义了服务原语和初始化参数。

* “->” 意味着两件事情 （i）由于外部处理或者通信阻塞，存在一些时延（ii）右边的服务原语是左边服务原语导致的。

序列的名称必须一对一地映射服务序列图中的名称。输入名称在有效服务启动时，会放在服务原语后的括号中，它应该是有效的。同样作为服务原语设置的输出名称也应该是有效的。

## 3.4 定义基本功能块
有四个主要元素描述基本功能块，（i） 上一节描述的外部接口。（ii） 内部变量 （iii）算法 和（iv）执行控制图（ECC） ，它定义了事件，状态和算法执行之间的关系。如图3.1 描述的。

### 3.4.1 内部行为

由两方面来描述功能块的内部行为-算法体和功能块执行控制。基本功能块通常包含一个或者多个算法。每个算法都是资源调度函数响应功能块输入的事件时调用的。当算法执行时，它会处理输入，输出和内部变量。产生新的内部和输出变量。内部变量用来采集算法不宜在功能块接口输出的结果。和输出变量一样，内部变量在每次调用时被训练（比如PID 算法的积分/微分部分）当一个算法完成它的执行时，它会“点燃”输出事件，通知外部数据已经就绪，可以被其它功能块“消费”。

注意：算法不能访问功能块外部的任何数据，这是一个非常重要的特点，以保证功能块是自包含（self-contained）的。与他们在哪里使用无关。

IEC61499 没有定义任何的语言用于算法的定义。任何高级语言都能够使用，输入输出变量和算法内部定义和提供的变量之间可以映射。我们在后面看到，在PLC 语言标准IEC 61131-3 中的结构文本（structured text  ST) 以及java 都是用来表述功能块算法行为的高级语言。都是好的例子。

基本功能块行为的一个重要方面是算法执行和事件之间的关系和建模。这通过叫做执行控制图（Execution Control Chart  ECC)的概念来获得。和功能块的其它特性一样，也可以使用图形或者文本格式来定义。

每个基本功能块需要ECC 来定义下列事项

* 功能块的内部状态

* 功能块如何响应每一个输入事件

* 当响应输入事件时，哪一个算法，并以何种顺序执行

* 当相应的算法完成了它的执行后，根据输入事件和ECC 当前状态点燃那些输出事件

ECC 是一种形式化的状态转移图，他和IEC61131-3 中的图形序列功能图类似，不过，作为一种状态模型技术，它在行为和功能方面是不同的，不要和图形程序设计语言（比如SFC）搞混了。

![图 3.7](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-7.png)
 
图3.7 是表明ECC 主要特点的一个例子，接口元素来自于图3.2 的通用功能块接口。在这理，ECC 具有四种状态 START，State1，State2和State3.他们对应了该功能块的四种状态。START 状态是功能块建立时的初始状态，当进入State 时，算法Alg1 执行，并输出EO1 事件。当进入状态State2时，算法Alg2执行， 进入状态State3  后输出EO2 事件

状态的转换的条件是： a) 一个事件 b） 一个事件和Boolean 表达式 c)Boolean 表达式，没有事件 d） 没有事件无条件（也就是总是True）表3.2 是该ECC例中转换条件的列表。
 
在较为复杂的功能块中，状态可能表示了该功能块的基本状态或者模式。

### 3.4.2 执行控制图（ECC） 的特性

标准定义了一系列使用ECC 的特性和规则，总结如下：

一个基本功能块只有一个ECC，它可用图形定义，也可以文本方式在功能块类型定义的外部控制块（execution control block ）节中定义

- 每个ECC 可以有一个或者多个状态，他们可用用圆圈或者方块表示

注意，在本书中，用方块表示ECC 状态。

- 每个ECC 状态能有零个或者多个动作。每个动作通常和一个算法或者一个输出事件关联。当进入一个状态时，该状态定义的动作会一个接一个地执行。一个操作会是零算法，只是点燃一个输出事件。也可以是一个没有输出事件的操作。通常一个状态至少有一个操作输出事件通知外部世界，某些输出更新了。
作为一个例子，图3.8 中，一个State 状态具有三个操作，调用算法Alg1，Alg2和Alg3

![图 3.8](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-8.png)

- 第一个和最后一个当他们完成执行时，分别触发输出事件EO1和EO2

ECC 不能改变功能块内部说明的变量。

- 转换（Transitions） 定义了可能的状态转换。转换通过转换条件来引导。转换条件又输入事件，引导条件构成。引导条件是输入，输出和内部变量的布尔表达式
 
### 3.4.3 基本功能块的执行

标准非常精准地定义了基本功能块输入事件触发ECC 中的状态变化，由资源调度功能块算法，最后产生输出事件。这些行为的主要方面总结如下
-资源维护应用程序中事件的发生，递交输入事件给功能块实例。这里，资源保证每次只递交一个事件。

资源将功能块的执行视为最基本的单元（atomic）这意味着只有当前面的事件触发的执行完成后才能递交新的输入事件。

只有由当前活动状态（也就是转换的前一个状态）引发的转换条件满足时，资源才允许ECC内部的状态变化

![图 3.9](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-9.png)

图3.9 中一个简单的状态机描述了ECC 的执行和用于评估的基本功能块执行行为。它有三个状态组成。按下列条件产生四个转换（t1 到t4）引起状态改变。

t1资源递交一个输入事件，与之相关的所有输入变量被采样，存储在功能块内部。 

t2 当前活动状态的所有输出转换计算为FALSE 所以没有EC 转换发生

t3 一个转换条件计算为TRUE 产生EC 状态转换，转换到EC 状态

t4 所有的活动状态的动作都完成了他们的执行。
 
### 3.4.4 基本功能块实例的行为

无论是使用文字，还是图形说明，它都能够在应用和复合功能块中通过基本功能块类型定义基本功能块的实例。基本功能块的实例具有它们的类型定义中定义的行为。但是拥有自己的存储空间用于存储它的输入，输出和保持它的ECC 状态的变量。换句话说，每个基本功能块二点状态和其它功能块是不同的。

基本功能块说明所在的资源在第一次激活功能块之前，要初始化每个基本功能块。这一初始化包括：

* 设置每个输入输出和内部变量一个初始值，初始值会在功能块类型定义中说明。当没有给出初始值时，将取特定数据类型的缺省值。例如，Bool 输入没有定义的话，初始值总是初始化为FALSE-布尔变量的缺省初始值。

* 算法内部状态初始化。例如，如果一个算法已经使用IEC61131-3 顺序功能图（SFC）语言定义，那么该算法复位到SFC的初始步。

* 该实例ECC的初始状态设置为活动（active），其它状态为不活动。

### 3.4.5 基本功能块实例

三选二 表决器实现

第一个例子是表决器功能块。已经在接口规范异界使用过。他将实现成为一个基本功能块。为了为描述的行为建模，使用在图3。10的状态和转换。一旦在启动状态Ready 输入Vote 输入事件，进入Vote 状态，算法VoteAlg 被执行，这个算法完成表决，它完成后触发Voted 输出事件，通知后续功能块表决结果。

如果表决结果为正，状态VotedPos 被激活，否则回到Ready 状态。当Vote Pos 状态被激活，一个Reset 输入事件导致转换到Reset 状态-调用ResetAlg。触发Ready 输出事件，最后回到Ready状态，等待下一个表决请求。算法使用IEC6131-3 结构化文本语言来表达。

如图3.10的右边。

![图 3.10](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-10.png)

描述Voter 功能块内部结构的文本语法如下：
```
FUNCTION_BLOCK VOTER (* Voter FB *)
EVENT_INPUT
(* Interface definition omitted, can be found in last
section *)
END_VAR
EC_STATES
Ready;
Vote : VoteAlg -> Voted;
VotedPos;
Reset : ResetAlg -> Ready;
END_STATES
EC_TRANSITIONS
Ready TO Vote := Vote;
Vote TO VotedPos := [State = TRUE];
Vote TO Ready := 1;
VotedPos TO Reset := Reset;
Reset TO Ready := 1;
END_TRANSITIONS
ALGORITHM VoteAlg IN ST; (* Voter algorithm *)
State := (A AND B) OR (A AND C) OR (B AND C);
END_ALGORITHM
Figure 3.10 Voter example execution control chart
60 Modelling control systems using IEC 61499
ALGORITHM ResetAlg IN ST; (* Reset Algorithm *)
State := FALSE; (* Reset the state output *)
END_ALGORITHM
END_FUNCTION_BLOCK
```

在这个文本语法实例中有几点要注意：

- 定义了功能块的内部状态和相关触发状态之间转换的事件。这在EC_STATES 和EC_TRANSITIONS小结中说明。

- 包括算法和输出事件的动作在功能块定义的EC_STATES小节中定义

- 每个算法都在ALGORITHM小节中定义。指定了语言的类型，随后是使用该语言表达的算法。在这个例中ResetAlg 和VoteAlg算法都使用结构化文本语言定义。

IEC 61499 并不排斥使用其它语言来定义算法的内容，比如JAVA或者C。事实上IEC61499 并没有定义算法定义的文本语法。但是运行使用任何已有的标准化文本语言。
 
Ramp 生成

在第一个基本功能块的例中，ECC 是采集功能块状态的主要元素。与之对比，在第二个例中，我们考虑一个算法类基本功能块，其功能主要在算法中定义。让我们来考虑一个非常简单的Ramp 功能块需要的行为。

这是一个渐变（ramp） 功能块，它在有Duration输入给定的事件内，从输入X0 给定的值渐变到输入X1给定的值，Cycle 输入定义渐变输出更新之间的时间间隔。该功能块同时还检查输出值是否超过输入PV ，当出现这种情形时，Hold 输出为TRUE假设Ramp 功能块被反复地调用。更新率有Cycle 时间给出。例如它可以配置成每200ms 执行一次。

这个基本功能块的图形定义包括静态外部接口定义，内部变量，执行控制图和算法。他们在图3.11 中给出。Ramp 功能块的行为在这类型说明中完全地被定义。

![图 3.11](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-11.png)

当INIT 状态激活时，反映Ramp 行为的输入值 X0，X1，Cycle和Duration 被存储。INIT 状态激活也调用初始化算法（InitAlg），它初始化内部时钟变量T，当初始化算法结束时输出事件INITO 被点亮。

同样地，当收到事件REQ 时，转换到状态Ramp，引起RampAlg 算法运行。它根据X0，X1 Cycle和Duration 的值计算新的输出值和更新时间到Ramp T。同时，该算法检查输出值是否超过PV，如果超过的话，输出Hold 设置为TRUE。

该功能块的文本语法留作读者的作业。读者可以参考上一个例子的文本语法。信息在附录E 中
 
## 3.5 定义复合功能块

复合功能块提供了一种以分层方式将基本功能块，复合功能块和服务接口功能块构建成更加复杂功能块的方法。复杂功能块的类型定义包括了选择类型的功能块实例说明，它们通过数据和事件连接互联。该标准将复合功能块内部的功能块看作为元件（Component）功能块。成员功能块之间的数据连接定义了功能块输入到输出的数据传输。而事件连接定义了复合功能块内部的功能块的执行顺序。

### 3.5.1 复合功能块类型说明的规则

对于复合功能块类型的说明，有一系列的规则和限制。特别是关于外部事件和数据输入输出和内部功能块的连接方面。这些规则的提出是应为事件不能够直接的扇出。也就是说，事件输入和事件输出之间必须是一对一连接。使用SPLIT 功能块能够将一个事件产生多个并发的事件。这是IEC61499的的一个特殊功能块，我们将在第六章讨论。相比之下，数据输出允许一个数据源驱动多个不同的数据输入。

事件连接的规则

下面的规则适用于复合功能块事件输入输出和部件输入输出之间的连接

* 每个复合功能块的事件输入必须连接到一个内部元件功能的输入事件。或者直接“穿过式 “的连接到复合功能块的事件输出。也就是说，事件输入不能够直接连接到多个不同元件功能块的事件输入。

注意，必要时，事件功能块（SPLIT）能够用来建立扇出事件。详见第六章。

* 每个元件功能块的事件输入必须明确的连接到一个元件功能块的输出事件，或者一个复合功能块的事件输入。

* 类似地，元件功能块的每个事件输出只能连接到一个确定的元件功能块的输入事件，或者复合功能块的事件输出。

* 每个复合功能块的输出事件必须连接到一个确切的元件功能块的输出事件或者直接连接自复合功能块的输入事件。

注意：有些元件功能块的输入输出事件会保持不连接（unconnected）在这种场合，与非链接输入事件关联的算法不被执行。

数据连接的规则

下面的规则适用于复合功能块数据输入输出和元件功能块输入输出之间的连接。

* 复合功能块的每一个数据输入 （a）能够连接到内部元件功能块的一个或者多个数据输入，或(b) 直接连接到复合功能块的一个或者多个输出，或（a）,(b)两者皆有之。

* 每个元件功能块的数据输入既能够是（a）,不连接，或者（b） 连接到另外一个元件功能块的输出，或者（从） 连接到复合功能块的数据输入。很明显，标准不允许一个元件功能块的输入连接到多个输出。因为这样输入端会有不确定的值。

* 每个元件功能块的数据输出能够（a） 不连接，或者(b) 连接一个或者多个元件功能块的数据输入，或者（ c）连接一个或者多个复合功能块的数据输出。

* 每个复合功能块的数据输出必须连接到（a）一个元件功能块的数据输出，或者(b) “穿过式“连接到复合功能块的数据输入。

### 3.5.2 复合功能块的执行

一个复合功能块的实例能够在一个资源中，作为应用网络的一部分而建立。既可以存在于顶端，也可以存在于其它大型复合功能块的内部。在所有的情形下，复合功能块的执行是由它事件输入端到达的事件来决定的。标准建立如下简单的规则来确定事件如何被处理。

* 如果一个复合功能块的输入事件直接路由到复合功能块的事件输出，在事件输入端产生一个事件将会在功能块的事件输出产生一个事件。

* 如果一个输入事件连接到一个内部元件功能块，输入事件的出现会导致元件功能块的输入事件端到达一个事件。该元件功能块然后通过资源调度功能调度执行。

* 同样地，如果一个元件功能块的输出事件连接到另外一个元件功能块的输入事件，那么，第一个的输出事件会引起第二个功能块调度执行。

* 如果一个复合功能块的输出事件连接到元件功能块的输出事件。当元件功能块产生一个输出事件，复合功能块的输出事件端将会产生一个输出事件。

这些简单的规则提供了事件和功能块执行的逻辑，总的一句话，事件通过功能块网络传递。从复合功能块的输入端推进到它的输出端。

### 3.5.3 复合功能块实例

考虑一个功能块的例子，它的外部接口如图3.12 所示。我们用它来演示复合功能块的许多特性。注意，它具有许多与基本功能块相同的外观特征，实际上从外观上看，仅从一个功能块的外部接口无法区分基本功能块和复合功能块。

![图 3.13](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-13.png)

我们现在来了解这个功能块的行为，表明它为什么建模成一个复合功能块。这个功能块的目的是产生图3.13 中的锯齿波。输出反复从0.0 到目标值的斜波，当复位和再启动，波形回到0.0。

图3.14 表明复合功能块的图形体，它被描述称为功能块网络相互连接构成一个新的功能块。在这种场合，一个附加的功能块

![图 3.14](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig3-14.png)

## 3.6 小结
在这一章我们涵盖了功能块类型定义的各个重要内容。我们了解了如何将功能块类型来建立功能块实例。进一步地，我们了解了功能块实例如何在新的类型定义中使用，分层构建更高功能性的功能块。尽管设计能够图形化地建立，我们也注意到，标准同样也定义了形式化文本语法格式，作为表示功能块类型的另一种形式。

小结一下：

* 有两种类别的功能块：（i）基本功能块和（ii）复合功能块

* 所有功能块类型都具有一个外部接口，由静态和动态两部分构成

* 静态接口定义事件和数据输入输出以及使用WITH 修饰符关联数据到事件。

* 动态接口描述有若干的服务序列图构成。它们描述功能块输入输出的事件流。

* 接口描述是在应用或者复合功能块中使用功能块需要的所有信息。

* 基本功能块的行为是以执行控制图（ECC），一个或者多个算法以及内部变量来定义的。

* 复合功能块是以功能块网络来定义的。

* 所有的功能块定义都既可以图形方式，也可以文字方式。图形方式和文本方式是可以相互转换的。
