---
title: 第五章 服务接口功能模块
description: 服务接口功能模块
toc: true
authors:
tags:
categories:
series:
date: '2021-01-02'
lastmod: '2021-01-02'
draft: false
weight: 50
---

# 服务接口功能模块

本章研究一类特殊的功能块，它们提供与所有资源和通信系统的接口。

* 讨论为什么需要服务接口功能块，用在哪里？

* 讨论在服务接口功能库类型定义中标准输入输出数据和事件点。

* 讨论如何用服务循序图（service sequence diagrams）来描述服务接口功能块的行为

* 考虑某些服务接口功能块实例和了解它们用在哪里

* 讨论在标准中定义的两种通信模型以及对应的通信服务功能块

* 最后，我们研究管理功能块，它们用来在资源和设备上建立，管理功能块。

## 5.1 概述
到目前为止，我们重点关注了使用功能块为独立的应用建模。在第二章，我曾经研究过一个简单的分布式应用，它只有增加了服务接口（Service Interface (SI)）功能块，才能够在资源之间相互传递数据和事件。实际上， 功能块之间的任何的交互，都需要一个SI 功能块。无论是在一个资源中，还是与外部世界交互。IEC61499 没有标准化成为特殊类型服务接口。而是用一组标准的输入输出变量和输入输出事件来规范这类功能块。

还有一些特殊的标记用来描述交互的顺序，比如发送请求，在SI功能块执行过程中等待外部发生响应。

我们现在将考虑我们哪里会需要SI 功能块，在工业控制器中，很明显需要读取物理输入值，例如从压力和温度传感器传来的值。也需要写值到执行机构。例如，驱动诸如阀门，泵，电机等等。同样，也需要通过串行通信链路发送值，发送数据套外部控制器，驱动显示器，从显示面板和其它HMI 设备读取数据。这都是使用资源与外部交互的例子，可以使用不同的SI 功能块建模。

在工业控制系统中的一些使用SI 功能块建模的例中如表5.1 所列。

## 5.2 接口规范
SI功能块为应用提供外部服务。和其它功能块不同，它们不能完全使用IEC61499 建模。只是功能块的接口提供了该服务的模型。所以，为了简化这一任务，需要进一步定义SI功能块结构的接口规范。

### 5.2.1 服务接口功能块的标准输入输出

每个SI 功能块使用下列标准输入输出。尽管不是每个SI 类型定义需要使用所有这些标准输入输出。

事件输入INIT 这一输入用来初始化该功能块提供的特定服务，例如，它可以启动在一个串行链路上的数据传输。典型地，这个事件发送一组输入参数所为该类服务的特性。比如网络地址和波特率。

REQ 这个事件发起一个请求，从外部站点获取数据，例如，这个事件能用来发起一个发送请求，从外部设备获取数据。

RSP 这个事件给外部站点发起一个传输的响应，例如，它可以用来向一个远程HMI 设备发送数据，作为一个数据请求的响应。

事件输出

INITO 这是一个表示SI 功能块表示完成了初始化的输出事件信号，也就是说，作为接收到INIT事件的结果。它并不需要表示该服务初始化成功，一个STATUS 输出才用于该不目的。

CNF 当功能块完成了一个传输请求后，发送的确认事件。例如，它用来表示读取一个特定物理IO的请求被控制器的IO子系统处理了。

IND 输出一个“标志”事件。表示SI 功能块受到了一个外部站点的响应。

数据输入

QI：BOOL QI 和输入事件一起使用，简单地用来作为输入限制符（也就是允许和禁止服务执行）

例如当用来作为一个初始化事件时，TRUE 表示由该功能块提供的服务应该初始化，而FALSE 表示该服务应该被中止。

PARAMS AND 这个输入表示保留了一组语该SI 服务相关值的数据结构。i中的数据类型和数量由功能块提供的服务类型确定。SI 功能块类型定义了PARAMS的结构和缺省值。在输入只能和INIT 事件一起使用，用于服务的初始化。

例如，一个通信SI功能块的PARAMS 输入可以包含网络地址信息，和其它通信特征。再或者，当写入值到输出设备时，这些参数将包含硬件地址（比如插槽，模块，通道）。

SD_1,….SD_m :ANY 这些数据输入用来与请求和响应发送。输入的数量，数据类型由该功能块提供的服务类型决定，由SD_1,....SD_m 标志
  例如，当写入值到输出设备时，这些值包含了写入的数值。

数据输出

QO： BOOL 这个限定符输出用来标志服务对于任何输入事件是否成功地完成。例如，跟随初始化INIT 事件，TRUE 表示成功地启动，FALSE 表示 该服务初始化失败。

STATUS：ANY 该数据伴随任何输入事件后输出，用来提供上一个输入事件处理的结果。例如：当使用INIT 初始化一个服务不成功时，将会设置状态数据。，同样地，当用一个REQ 向远程设备发送数据失败时，状态标识失败的原因。

RD_1,….RD_m:ANY 这些输出用来传送接收到的数据，输出的数量，数据类型由该功能块提供的服务类型决定。

### 5.2.2 服务接口功能块的服务序列图

除了静态接口以外，服务序列图不仅描述SI 功能块的动态行为（也就是它的行为和如何使用）。对于SI 功能块而言，在服务序列图中使用的接口两边是功能块接口和资源接口。功能块接口由功能块类型名称标注。对于由应用触发的SI 功能块来讲（比如，读输入的功能块），习惯将功能块接口放在左边，而资源放在右边（图5.1 的左栏）。对于资源是主要触发者的SI 功能块而言（比如从网络接收消息的功能块），习惯将资源放在左边，而接口放在右边（图5.1 右栏）

![图 5.1](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig5-1.png)

事件名称后缀“+”，表示事件成功地（或者 正常）交互，而后缀“-” 表示不成功（或者 不正常）交互。对于输入事件，后缀“+” 表示输入QI 将与事件一起设置为TRUE，与此相反，后缀“-” 意味着输入QI 设置为FALSE。

例如，事件INIT+ 表示当QI 设置为TRUE，服务成功地初始化时收到该事件。与此相对比，INIT- 表示事件收到时QI 设置为FALSE，服务被中止。

输出事件也与此类似，后缀“+”表示成功，或者正事件，而后缀“-”表示事件关联的交互未成功，或者负交互。而输出事件后缀“+”表示QO设置为TRUE，而后缀“-”表示QO 将设置为FALSE。
 
以CNF-为例，是一个服务请求的负确认。表示交互某种原因未成功。如果这发生在响应一个请求，那么它将代表提供的数据不正确，或者整个服务有某些问题。典型地，STATUS 输出会给出更进一步的信息。

例如，SI功能块的服务功能是读取一个输入，它能够检测到没有电源。于是，在图5.1左下方描述了该功能块无法完成读取输入值的情形。

除了刚才描述的SI 功能块接口的可见行为以外，能够给出关于服务行为更进一步的描述。。类似于第三章中描述功能块行为的方式类似。能够在服务序列资源端增加服务原语（例如：InitialiseService，Receive Message，ReadInputs）。

在图5.1中的所有服务序列图都包含了描述服务原语。

服务原语定义

有一套SI 功能支持的所有正负形式的标准事件的语义定义。IEC61499 定义这些各种事件形式为服务原语。表5.2 提供了标准服务原语的定义。它具有两栏，分别对应通信服务和通用服务。很明显，复杂的SI 功能块，可以考虑使用这些服务原语做各种组合，形成正常和非正常交互。

伙伴服务接口功能块

到目前为止，我们只是考虑与资源提供的服务交互的SI功能块，在若干场合，会有一对SI 功能块。它们相互通过服务交互。例如，一对通信功能块允许不同资源之间交换数据。它们由发送和接收功能块组成。在其输入端给予发送者的数据，将传送到接收者，并在它的输出端提供。

类似服务序列图为适配器行为建模类似，标准指明，可以使用服务序列图来显示两个伙伴之间的交互。在这种情况下，资源部分被省略，使用两个伙伴功能块的接口。这一服务序列图在图5.2 中显示。两个垂直的线表示发送者和接收者之间消息传输过程中的除了和时延。与描述适配器接口的服务序列图不同，对于伙伴SI 功能块来讲，不需要两边调用服务交互。如果只是调用服务的本地部分，那么另外一边不需要通知。

这显示在图5.2 NormalInitialisation 服务序列图中。

服务序列图的文本语法能够包含交互两端的定义。例如，发送者额类型定义可以包含相关接收者的行为。为了展示这一点，下面的文本语法定义了数据传输服务序列图，作为发送者类型的一部分。也就是它描述图5.2 中的NormalDataTransfer 服务序列图。

SEQUENCE NormalDataTransfer

Sender.REQ+(SD_1,...,SD_m) -> Receiver.IND+(RD_1,...,RD_n);

END_SEQUENCE

注意：接收者的定义简单地参考发送者。统数注意，在这个例子中标志SD_1,…,SD_m 只是表示发送者/接收者功能块是通用的，能够裁剪适合特别的应用。在实际系统中，每一对发送者/接收者都需要指定固定数量，给定数据类型数据项。

在这种形式的伙伴SI 功能块行为建模中的一个缺陷就是资源的行为和使用的特殊服务没有建模。为了提供这些信息，额外的服务序列图描述需要建模。
 
## 5.3 类型定义

IEC61499 指明了使用通用的术语来构建SI 功能功能块接口的方法。每一个SI 功能块提供了某种服务，比如读取I/O，在网络上发布值等等。所有建议给每个功能块类型的名称反映功能块提供的服务。比如，ValuePositioner，HMIWriter 等等。

### 5.3.1 通用服务接口功能块类型

值得注意的是，SI 功能块是响应应用的某个激励来启动一个服务的。另一方面，SI 功能块响应一个外部请求，比如来自于HMI面板的信号，从应用中获取一个值。SI 功能块能为两类行为建模。

![图 5.3](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig5-3.png)

图5.3 描绘了两个SI 功能块的例子，应用了IEC61499 标准。这些功能块依然是“通用”的，意思是它们没有给定一定数量的输入和输出。输入和输出的数据类型也定义称为关键字ANY。换一句话说，这是一个类型定义的粗略模板。在实际应用领域，需要进一步的细节和数据类型设计。
 
REQUESTER 功能块提供了一种服务，IEC61499 中称之为“应用发起的交互”-换句话说，请求外部数据是由应用中产生的事件触发的。PARAMS 输入用来指定服务特定的配置参数；输入SD_1，。。。。SD_m 提供请求的参数，也就是说，发送请求命令字符串和参数。RD_1,….RD_n 输出用来响应从服务接收到数据。当功能块发出确认输出事件时，它们会提供。

相比之下，RESPONDER功能块·提供”资源发起的交互“的服务。请求数据从外部资源到达。以IND 事件和输出数据RD_1,…..RD_n 产生为标志。在这种情况下，应用需要能够响应在任何时候产生的事件。对请求的响应通过写入数据到RESPONDER输入SD_1,…SD_m .并且在响应RSP 事件输入端触发一个事件，通知服务收到的数据处理完成了。

两个通用SI 功能块类型的这一行为在图5.4中用服务序列图的形式显示。这些图表明典型的功能块生命周期由初始化，正常使用和最后中止组成。对于REQUESTER 和 RESPONDER的服务序列图中开始和最后服务序列是相同的，不同的是两者的NormalDataTransfer服务序列。可清楚地看到REQUESTER收到来自应用的REQ 事件时完成服务请求，而RESPONDER的情形，服务接管活动部件，通过IND 事件通知应用。

两者相结合，REQUESTER 和 RESPONDER SI 功能块能够使用某种通信或者某种网络设施连接的资源之间交换数据。所以，如同上一节描述的那样，典型的一组伙伴SI 功能由REQUESTER 和RESPONDER，构成。

### 5.3.2 服务接口功能块类型实例

图5.5 显示了两个SI 功能块更进一步的例子；IO_WRITER 用于向物理输出写值，而IO_READER 提供从选择的物理输入读取值。两个功能具有类似的方法。
让我们考虑IO_WRITER 功能块是如何使用的。应用至少一次请求该功能块的实例，写出数据到物理输出口。为了设置该服务，应用必须首先发送INIT 事件，并且QI 输入设置为TRUE。而PARAMS 输入设置服务的标志性特性。PARAMS 输入要包含细节，比如写操作更新速率，失败重试次数等等。所以，通过设置的输入SD_1 到一个输出地址。数据能够发送到选择的输出端。比如机架，插槽，通道和IO点。事件输入REQ 上的事件发起写操作。

一段时间以后，当硬件IO系统完成写操作，一个输出事件CNF 将会产生，确认写操作完成。输出STATUS 提供操作是否成功的状态。如果操作失败，STATUS 将包含相应的错误码。输出RD_1 提供从输出设备读取的反馈值。这能确认写操作是否成功。

IO_READER 功能块一类是的方式操作。当使用INIT 事件，QI和PARAMS 输入初始化服务之后，在SD_1上设置IO地址，并且在事件输入端发送一个事件，就读出任何的物理输入值。 一段时间过后，当时数据已经从输入传感器读出，在输出事件CNF 产生一个确认事件。读操作成功与否由STATUS输出值表示，如果成功，从输入读出的值将呈现在输出RD_1 端。

注意： 在这个例子中，两个功能块都是采取了应用触发SI 功能块类型的方式。对于IO_READER ,也可以选择资源触发的方案。在这种情形下，PARAM 输入同样包含IO 地址信息。当新的值可用时，服务通过IND 事件通知应用。或者适当时间周期后释放。

IO_WRITER 和IO_READER 是相对简单的访问硬件IO的一对SI 功能块。可以考虑，更复杂功能块，比如在一个操作中读写多个IO点的值。
注意：发送REQ事件触发请求到接收到确认事件CNF 之间的事件是由多个因素决定的。

* 资源调度系统的装入

* 设备操作系统响应资源请求的速度。

* 发送请求到物理IO 点的时间

### 5.3.3 文本语法-服务接口功能块实例
展示定义SI 功能块的文本语法的最好方法就是了解图5.5 中IO_WRITER 功能块文本性定义：
```
FUNCTION_BLOCK IO_WRITER (* IO_Writer Service Interface *)
(* Event definitions *)
EVENT_INPUT
INIT WITH QI, PARAMS;
REQ WITH QI, SD_1, SD_2;
END_EVENT
EVENT_OUTPUT
INITO WITH QO, STATUS;
CNF WITH QO, STATUS, RD_1;
END_EVENT
(* Variable definitions *)
VAR_INPUT
QI : BOOL; (* Event input qualifier *)
PARAMS : IO_PARAMS; (* Service parameters *)
SD_1 : IO_ADDR; (* Output address *)
SD_2 : IO_VALUE; (* Output value *)
END_VAR
VAR_OUTPUT
QO : BOOL; (* Event output qualifier *)
STATUS : ANY; (* Service status *)
RD_1 : IO_VALUE (* Returned value *)
END_VAR
Service interface function blocks 101
(* Service sequence definitions *)
SERVICE IO_WRITER/RESOURCE
SEQUENCE normal_initialisation
REQUESTER.INIT+(PARAMS) -> REQUESTER.INITO+(STATUS);
END_SEQUENCE
SEQUENCE abnormal_initialisation
REQUESTER.INIT+(PARAMS) -> REQUESTER.INITO-(STATUS);
END_SEQUENCE
SEQUENCE normal_data_transfer
REQUESTER.REQ+(SD_1,SD_2) -> REQUESTER.CNF+(RD_1);
END_SEQUENCE
SEQUENCE abnormal_data_transfer
REQUESTER.REQ+(SD_1,SD_2) -> REQUESTER.CNF-(STATUS);
END_SEQUENCE
SEQUENCE normal_termination
REQUESTER.INIT-() -> REQUESTER.INITO-();
END_SEQUENCE
SEQUENCE abnormal_termination
REQUESTER.INIT-() -> REQUESTER.INITO-(STATUS);
END_SEQUENCE
SEQUENCE resource_initiated_termination
-> REQUESTER.INITO-(STATUS)
END_SEQUENCE
END_SERVICE
END_FUNCTION_BLOCK
```

这里与第三章通用接口规范相比，我们看到SI 功能块不包含任何除此以外的额外信息。

注意：最后一个用于resource_initiated_termination序列定义中，在”->”符号的左边没有交互的组件。这是因为在这种场合下，交互是由资源外面的某个不知名的站产生的。例如。当电源突然失灵，设备会发送一个主动的交换给整个资源的接口，中止IO_WRITER 服务。

## 5.4 通信服务接口功能块
IEC61499 的目标是分布式工业过程测量和控制系统。

位于不同资源的应用部分之间的相互通信是非常重要的。

### 5.4.1 单向交互（unidirectional transactions）的功能块

单向交互模型能用来从一个资源向一个或者多个其它资源发送数据。对于这个模型，IEC61499 定义为一对PUBLISH/SUBSCRIBE 功能块。如图5.6 所示。

![图 5.6](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig5-6.png)

使用这些功能块，应用程序能够用PUBLISH 功能块发送数据，使用SUBSCRIBE 功能块接收数据。在此，发送和接收是完全解耦的。也就是说，可以添加，去除SUBSCRIBE 功能块，而不影响其它的SUBSCRIBE 功能块和PUBLISH 功能块。
 
描述该单向交互的主服务序列图如图5.7所示。当使用INIT 输入事件初始化时，两个功能块连接到本地的通信服务（也就是网络驱动），并且完成发送和接收数据所需的初始化。两边能够相互独立地完成它们的初始化。在PARAMS 中规定了PUBLISH 功能块如何发送消息。并且能够被SUBSCRIBE 功能块能够接受，标识和解码。

在正常的操作过程中，PUBLISH 功能块由REQ 事件触发启动。PUBLISH 功能块获取输入数据（也就是SD_1,…SD_m） ,形成适当的消息发送到网络，成功发送消息之后，由PUBLISH 功能块发送一个CNF 输出事件。当SUBSCIBE 接收到消息时，消息的数据施加到RD_1,…RD_m 并且发送IND 事件。应用程序接收了数据后，使用RSP事件通知SUBSCRIBE 功能块。

### 5.4.2 双向交互功能块

当在一个应用分布在两个资源A，B，如果需要从A 发送请求数据，接收B的响应。IEC61499 提供了CLIENT/SERVER SI 功能块满足这种双向数据交互的形式（图5.8） 在资源A 的CLIENT 功能块向B资源中的SERVER 功能块发送请求。SERVER 功能块响应，并发送响应数据给A 中的CLIENT 功能块。

![图 5.8](https://cdn.jsdelivr.net/gh/IEC-61499/img@21.1/Fig5-8.png)
 
双向交互的服务序列图如图5.9所示。它清晰地表明了与单向交互的差别。首先，主要的差别在初始化。它需要服务器先于CLIENT 初始化。

和PUBLSIH 功能块类似，CLIENT功能块当收到REQ事件时，获取它的输入数据（SD_1,。。。。SD_m） 建立网络消息并且发送出去。与单向模式的不同是，CLIENT 功能模块将等待SERVER功能块的响应。SERVER 功能块会更新它的输出数据（RD_1,….RD_m）,并且通过IND 通知应用程序。应用程序处理这些数据，通过设置SERVER功能块的输入数据和触发RSP事件产生相应的响应。SEEVERv功能块将数据放置到网络消息上，回送给CLIENT 功能块。CLIENT 功能块输出数据，通过CNF事件通知应用程序。

这对CLEINT和SERVER 功能块为远程功能块建立了本地“代理”。

## 5.5 管理功能模块

最后一种在标准中定义的SI功能块涉及服务的装入，启动和初始化功能块的执行。标准定义了通用的管理功能块如图5，10所示。它能够使用不同的管理命令定义，构建一系列服务功能块。标准定义了9个命令（列于表5.3和5.4） 中。它们提供了管理分布式应用所需要的配置，重配置任务的必要手段。这些服务的描述以及它们如何地工作在标准中只给出了粗略的勾勒。这个领域非常难以建模。因为不同的系统会采用不同的机制来装入和建立功能块网络和启动已装入的应用。这是一个大的课题，无法用常规的方式建模。所以，IEC61499标准工作小组重新安排工作，将这部分工作包含到开发兼容概要的“可配置性”主题下（见8.3节和附件B）

作为一个极端，为了启动一个应用，系统可能需要所有的功能块和支持资源库编译成二进制格式。下载到各个设备中。另一个极端的状况，设备需要预装一个大的功能块库。例如，功能块定义要求是设备固件的一部分。

在这种情形下，建立应用只是简单地建立和下载在不同设备中构建应用功能块网络必需的连接定义。也有一些混合系统，一部分功能块在固件中，另一部分需要下载。

管理功能块支持的服务在表5.3和表5.4 中列出。

## 5.6 小结
