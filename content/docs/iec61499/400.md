---
title: 第四章 结构化应用
description: 结构化应用
toc: true
authors:
tags:
categories:
series:
date: '2021-01-02'
lastmod: '2021-01-02'
draft: false
weight: 40
---

在这一章，我们将综述应用（application是如何使用子应用（subapplication）分层构建为独立的子系统(sub-system)的。同时将描述功能块的交互是如何通过适配器（adapter）的概念来耦合的。

特别地，我们将

* 综述子应用在哪里会被使用，比较它们的行为和属性和复合功能块的区别。

* 描述子应用的分布式能力

* 考虑在自顶向下和自底向上应用设计方法中如何的使用子应用的。

* 使用适配器定义的公共接口耦合应用部分和功能块。

* 表明适配器在应用和不同功能块类型中的定义和使用。

## 4.1 使用子应用构造应用

一个应用可以使用子应用（sub application）进一步分解。子应用具有功能块的外部特性（比如数据和事件接口），但是能够包含功能块，可以是它们自己，分布在其它资源之上。

一个子应用可以看作被设计成为分布式的特殊形式的复合功能块。它可以运行在多个资源上。它具有和复合功能块类似的结构，但是当使用松弛的数据和事件，有一些规则需要遵守。子应用只能在更大的子应用或者应用中使用。而子应用本身可以和其它应用一样，使用基本功能块，复合功能块和服务功能块等等。

相比于复合功能块，子应用的一个鲜明的特点是它们可以在多个资源上运行。而基本功能块和复合功能块☞能在同一个资源上运行，也就是说，它们不能分割成几个部分在不同子资源上运行。然而，子应用是可以运行在多个资源上的，也就是说，它们是可分布式的。将表3.1 扩展一下，表4.1 总结了这些特性和其它两种功能块类型的比较。
 
 
### 4.1.1 子应用类型规范的规则

子应用构建的规则是：

* 一个子应用的实例能够在其它子应用或者应用中说明。

* WITH 结构不能用于子应用类型。因为事件和数据的关联与该子应用如何在资源中分布有关

* 子应用的输入输出变量和功能块类型的同样方式（图形的或者文字）说明。然而，对比与复合功能块，这并不意味着要为这些变量分配内存。所有子应用的输入输出值都存储在它元件功能块的接口中。

* 使用服务顺序图来描述子应用的动态接口行为。这和功能块类型接口的方式是相同的。

* 内含的功能块网络由功能块，子应用实体，事件连接和数据连接构成。说明的方式和复合功能块类似

* 图4.2 显示的子应用的这些特性与复合功能块的对比。

### 4.1.2 子应用的执行规则
子应用的实例能够在应用中说明，也可以在其它子应用中说明。不过，子应用的实例和复合功能块的实例由相当大的区别。事实上，它是一组功能块及其它们的连接的拷贝副本。在这个意义上讲，子应用相当于软件的宏或者是图形模板。

标准制定了子应用如何执行的如下规则

* 事件能够直接穿过子应用。于是，一个事件输入到达一个事件将立即触发事件输出的事件。

* 每个不是直接穿透的事件必须连接到一个内部元件功能块的事件输入。在这种情形下，当一个子应用的输入事件端到达一个事件时，内部元件功能块将接收到一个事件，并且调度执行算法。

* 当一个元件功能块执行时，它将产生一个或者多个输出事件。这些将依次触发在子应用中与它们连接的其它元件功能块的执行。

* 子应用中不直接路由到事件输入的事件输出必须连接到一个元件功能块的输出事件。当相应的功能块执行，并且产生一个输出事件时，该事件将传递到子应用的事件输出端。

### 4.1.3 子应用的实例

作为一个实例，考虑一个提供温度控制回路的子应用。它由一个模拟输入功能块，一个PID 控制功能块和一个模拟输出功能块构成，如图4.3 所示。这是非常典型地用于控制设备的温度。比如加热容器，或者加热炉。这个控制回路的主要功能是 (i) 测量当前的温度（ii） 将它的值和设置点的期望值做比较（iii）调节输出值，驱动加热设备校正温度。 这三个功能映射到三个元件功能块，构成该子应用。input1功能块读取外部传感器的当前值。PID1 功能块提供了PID 算法，它比较测量值和设置点值，并且产生一个输出值。Output1功能块获取PID 建立的值，并将它传输到外部执行器。

input1和output1 将构建成复合功能块。它们至少含有一个服务接口功能块。提供与底层控制器的接口，以便从控制器的硬件读取输入，输出值。服务接口功能块是一种特殊形式的功能块。提供了各种各样与物理设备或者通信系统的接口。它们将在第五章讨论。

这个子应用例子有两个事件输入，INIT和Run 。INIT 用来初始化内部元件功能块。Input1和Output1 功能块将初始化它们相应的服务接口功能块。INIT 同样触发PID 功能块读取它的输入变量，例如读取设置点的值，将它存储在PID 功能块中。设置点是控制回路将稳定的期望温度。一般来讲，PID 算法需要大量的参数，比如积分和微分需要的时间常数。为了保持例子的简单，没有显示出来， 它们方式设置与设置点SetPoint是一样的。Run 事件在子应用中传递。引发控制回路读取温度，根据PID 算法的计算值更新外部输出。在这个例子中，我们假设在应用中有另外的时间功能块提供规律的事件流，比如在Run 时间输入产生时间间隔为100ms 事件流。以保证TempControl 子应用规律化地被调用。这将确保以一个给定的扫描周期测量温度。并且该值传递给PID1，PID1依次产生新的输出值，调整热输出。

图4.4 表示了TempControl 子应用在一个简单的控制器中是如何运行的。它提供了一个蒸汽加热器的闭环温度控制。TempControl 子应用的输入是一个温度值，它是从一个传感器，比如热偶上读取的。子应用的输出驱动某种形式的执行器，比如蒸汽阀门，调节温度。

注意：在这个例子中，TempControl 子应用实践上是SingleVesselControlApplication 应用的一部分。该应用部署到一个单独的IEC61499 设备中。该设备内部只有一个资源。也就是说，所有的功能块在同一个资源上运行。

### 4.1.4 分布式子应用的实例（Subapplication distributed example）

到处为止，我们已经考虑了在单一资源上运行的子应用。IEC61499 的一个有意思的特性是能够重新安排应用和子应用。让它们以不同的分布式安排在不同的设备和资源上运行。并且仍然提供同样的功能。比如像图4.2 中描述的TempControl 子应用能够分解成更小的功能块网络段。让它们运行在不同的资源上。

在TempControl 的情形下，可以考虑下面的安排：

* 所有的功能块运行在一个资源上，也就是图4.1中显示的非分布式配置。

* input1，PID1和Output1分别运行在不同的资源上，也就是完全分布式。

* input1 运行在一个资源上，而功能块PID1，Output1 运行在第二个资源上，-一种分裂资源配置

* 功能块Input1和PID1 运行在一个资源上，而Output1 运行在另一个资源上-另一种分裂资源配置。

图4.5 显示了可以考虑的一种可能的物理系统配置。它显示两个控制器-DeviceA和DeviceB ，通过某种形式的网络系统连接，比如Filedbus 或者以太网。模拟输入连接到DeviceA 而执行机构现在由另一台设备DeviceB 驱动。现在这个子应用分布在两台控制器上，但是它们的内部功能任然是图4.3 原始TempControl 子应用类型定义的功能块确定的。

使用这一系统配置，图4.6 展示了第四种分布式安排，用于模拟输入和PID计算的功能块Input1 和PID1 运行在Device_A 的资源Resource1 上，而模拟输出的Output1 运行在设备device _B的另一个资源上。实际上，这样的安排意味着子应用TempControl 能够运行在不同设备的两个分离的资源上。

### 4.1.5 使用子应用的指南

子应用与复合功能块非常类似，以至于不太清楚社么时候使用它们。复合功能块以“原子”方式封装和隐藏内部实现（内部设计是使用者无法看见和修改的）所以复合功能块适合以可重用方式封装功能，使用者不需要内部的任何信息。相比至西安，子应用也是重用方式提供功能块网络，不过它同时采样了开放的模式，这就意味着可以根据应用或者系统配置直接做特定的调节（也就是参数）

下面是当使用子应用替代复合功能块的遵循规则

* 其它子应用要使用

* 应用和系统需要配置特定参数和调整，但是在容器的外部接口不足以提供它们

例如，子系统的过程参数需要由负责该子系统的过程工程师提供。换句话说，应用特定的参数嵌入在子应用中

* 功能块网络在映射阶段，具有分布到不同资源的潜在的需要。要使用两个或者多个服务接口功能块，不同的设备提供不同的服务。

* 在应用开发过程中，子应用可用使用自顶向下，自底向上或者混合的方式定义和使用。如果采样自顶向下的方式，开始是一个空的应用。然后是子应用的草图以及它们的接口，根据应用的需要，形成应用部件的分层架构。标识的子程序依次地顺序开发。如果需要的话，可以由不同的独立团队开发。在自顶向下设计方法下，已有的子应用和新定义的子应用与其它功能块一起构成新的应用或者子应用。混合设计模式是在自顶向下方式中使用已有的子应用。

## 4.2 使用适配器的结构化接口

对IEC61499 的一个最大的批评是事件和数据接口的分离。尽管在事件和数据来自于不同源时它是一个优点。但是通常它会导致设计空间的混乱。例如在图4.7中，为两个独立的应用部分交互建模。它显示两个功能块完成某些握手交互。FB1 发送一个事件和三个数据点给FB2.而FB2 发送两个事件和一个数据点返回给FB1。

除了设计空间的混乱以外，这个例子表明使用这种方式为两个功能块交互建模时暴露出额外的问题。

* 两个功能块的交互不是清晰可见的。进而，没有元素描述这个交互的语义（也就是两部分以什么顺序发送事件）

* 错误使用该接口非常容易发生。使用者可能忽略了连接需要的接口元素，也可能错误地连接接口元素（也就是两个连接的相互转变）

### 4.2.1 适配器的概念

为了解决这些问题，IEC61499 提出了适配器（Adapter）的概念。这个概念支持收集和组合这样的交互到一个清晰定义的接口中。使用适配器概念将这样的交互简化称为两边各一个单一的接口元素。它们之间只有一个连接。一个适配器可以用来连接数据和事件。也就是说，两个功能块之间任意数量的标识的输入，输出和相关的事件输入和输出。输入·输出的名称在适配器类型说明中定义。值得注意的是，适配器类型中没有算法，状态和常量。它只是扩展了功能块的接口。然而，通过适配器提供的数据和事件不包含在功能块的接口中。它们只是在功能块的内部可用。不能用于图形连接到其它功能块。所以说，适配器的概念用来改善信息的“隐蔽”和有助于顶层设计。

适配器可用看作为模仿了电子电缆。它通过插头和插座功能块。在功能块中使用的插头看作提供数据和事件，在功能块中使用的插座看作是请求数据和事件。从图4.7 的数据，事件接口转换到利用适配器概念的转变在图4。8 中描述。

功能块可以拥有不止一个适配器接口，提供特定的接口到一组不同类型的功能块。例如，我们想象一个处理模拟量输入的功能块，它具有分立的告警管理和校正功能块接口。

注意： 适配器接口不能不连接，任何已经指定了适配器接口的功能块，无论是插头，还是插座，都需要连接具有相反接口的功能块。

适配器的核心概念总结如下：

* 适配器连接结合了双向具有若干事件和数据连接的两个功能块的双向交易。

* 在功能块接口中，适配器端口使用“>>”标识。

* 功能块能够将适配器端口定义成请求（requesting）形式接口，在IEC61499 中称为“插座“，在功能块的左下方描绘（输入端）。请求接口意味着功能块请求这个接口的实现。

* 功能块能够将适配器端口定义成提供（Providing interface）形式接口，在IEC61499 中称为“插头Plugs“ 在功能块的右下方描绘（输出端）提供接口意味着该功能块提供这种接口的一个实现。

* 适配器连接总是连接相同类型的一个插头和一个插座。

* 适配器类型的接口以功能块类型接口的形式定义

* 插座和插头的接口相互镜像。这意味着从插头或者插座进入的事件或者数据会在连接的另一头离开。例如 触发FB1 的插头InterSkt的EI1事件，会导致FB2 插座InterSkt 的EI1 事件接收到事件。

注意：从软件建模的观点看，适配器概念与ROOM【20】或者UML2.0【22】中采用·的端口的概念非常接近。
 
### 4.2.2 适配器类型定义

以定义功能块相同的方式定义适配器类型。他有类型名称，事件和数据接口。输入输出变量通过WITH 结构与输入输出事件关联。接口说明可以通过图形方式或者文字方式（也就是使用文本语法或者XML 格式）来完成。接口以适配器接口的请求端（也就是插座）的视角来描述和存储在交换格式中。不过，有工具能够从适配器插座或者插头的视角来说明适配器接口。图4.9 描绘了图4.7例子中适配器类型的适配器接口说明。
 
注意，在IEC61499 中，如果只看接口，无法去分功能块和适配器。在这本书的图中，为了清晰地表明哪里采用了适配器，将它们画成了灰色。尽管这不是IEC61499 需要的。

适配器接口的文本语法描述如下：
```
ADAPTER Interact
(* Event definitions *)
EVENT_INPUT
EO1 WITH DO3;
EO2;
END_EVENT
EVENT_OUTPUT
EI WITH DI1, DI2, DI3;
END_EVENT
(* Variable definitions *)
VAR_INPUT
DO3 : DataType;
END_VAR
VAR_OUTPUT
DI1 : DataType;
DI2 : DataType;
DI3 : DataType;
END_VAR
END_ADAPTER
```

与功能块说明的最大区别是适配器说明使用关键字ADAPTER … END_ADAPTER 括起。

### 4.2.3 适配器类型行为建模

为了描述适配器类型的动态行为，IEC61499 允许像普通功能块那样定义适配器类型绘制服务序列图。对比功能块服务序列图，适配器的服务序列图定义插头和插座的交互。所以在服务序列图中，插头描绘在左边，插座描绘在右边。（图4.10） 进入插头或者插座的事件直接向前送出到适配器连接的另外一端。服务序列总是对称的。适配器接口的服务序列图的主要任务是描述事件的顺序，以及是哪一个发起交互。插头，还是插座。
 
### 4.2.4 在功能块中使用适配器类型

如同上面描述的那样，适配器类型的实例能够在功能块中用作插头，或者插座。在两种情形下，实例是用实例名称来标识的。在图形化表示中，插座在左下方描述和绘制-功能块的输入边。在文本语法，插座在SOCKETS . . . END_SOCKETS块中说明。插头在图形化表示的右下方说明和绘制。-功能块的输出边。在文本语法说明中，插头在PLUGS . . . END_PLUGS块中说明。为了从数据的输入输出中区分插头和插座，它们在图形表示中使用“>>” 符号作为标记。

在功能块类型说明中，插头和插座的输入和输出与功能块输入输出同样的方式使用。不过，需要注意的是，从语义上讲，插头或者插座的输出用作功能块的输入。将它们看作从适配器连接另一端接收来的事件和数据。插头或者插座的输入用作功能块的输出，将它们看作为发送给适配器连接另一端的事件和数据。

适配器能够应用于任何功能块类型（也就基本功能块，复合功能块和服务接口功能块）。插头和插座输入输出的特定用法依赖于使用它们的功能块类型。

我们在下面通过实例描述。

适配器在复合功能块中的使用

使用适配器的最直觉的方式是在复合功能块中使用。原因是插头和插座的适配器接口可以在复合功能块内部的功能块网络中显示。图4.11 显示了一个例子，在图4.8 中使用的功能块FB_Type2_1 。插头或者插座的输入和输出能够方便地在复合功能块中使用，将他们与内部功能块连接。在文本语法中，插头或者插座的适配器实例名称与接口单元一起作为输入输出的标识（例如：InterSkt.EI1）,这与使用组件功能块是类似的。
 
适配器子基本功能块中的使用

在基本功能块中，插头和插座的输入和输出能够在执行控制图（ECC）和算法中使用。在ECC 中，插头和插座的输出事件能够用来转移条件。而适配器的输入事件用于状态的动作语句。插头和插座的数据输入输出能够用于ECC 的状态转移和在算法中使用。为了区分功能块的输入输出和适配器的输入输出的差别。适配器实例名称作为标识符。图4.12 显示ECC 的一部分和一个利用插头输入输出的算法，插头的实例名称是InterPlg.
 
适配器在服务接口功能块中的使用

在标准中没有定义适配器在服务接口功能块中的使用。然而，插头和插座的输入和输出能够应用在服务序列图中。类似于使用功能块的输入输出。（图4.13），同样地，适配器的实例名称用来作为插头和插座输入输出的标识符。更进一步地，这表明服务原语中使用适配器事件和普通功能块接口事件在服务序列图中应用。

为了实现服务接口功能块，实现平台要指明处理适配器事件和数据的方法，这和处理服务接口功能块自身的事件和数据是类似的。
 
### 4.2.5 适配器使用实例
考虑一个机器的子系统，零件由传送带传递，并且有一个拾放单元从传送带取零件处理。图4.14描述了这个子系统。进一步地，能够通过拾放单元取回零件，并且传送回去。也就是移走零件，重新放置到传送带，在这个例子中，拾取装置在图4.14由两个线性轴X，Y以及一个夹子表示。在这个例子中，我们没有考虑传送带或者拾取装置的控制，而是集中如何为两个部件的控制程序通过适配器交互建立模型。
 
为了为传送带和拾取装置之间交互的适配器接口建模，我们将考虑床送带是提供接口（也就是 插头）而拾取装置是需求接口（也就是插座）。拾取装置按照这样的方式交互，如果在传送带上有一个零件可供取走，或者传送带有空位置可以接收零件时，传送带将通知拾取装置。
 
### 4.2.6 使用适配器指南

## 4.3 小结
